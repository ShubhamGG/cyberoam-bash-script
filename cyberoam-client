#!/bin/bash

ACK_TOLERATE_MAX=2
ACK_TOLERATE_SLEEP=10
LOGIN_COUNT_MAX=5
login_success=0
login_count=$LOGIN_COUNT_MAX
ack_success=0
option=0
optcount=0
quiet=0
verbose=0
name=$0
name=${name##*/}
function print_usage {
	echo "Usage: $name [-v] { [-q] [-d|-s] <username> | -l } "
	echo "-d : delete configuration file (if found) for username."
	echo "-s : save configuration file (override if already exists) for username."
	echo "-q : Be quiet i.e. don't send notifications of events."
	echo "-l : logout. Other way to logout is to send ctrl-c i.e. SIGINT to the running process of $name."
	echo "-v : give verbose output."
	echo "If -s is not specified, then saved config file for username is used (no input asked). If the config file doesn't exist, the login info needs to be inputted and is not stored."
}

#parsing options
[ $# -eq 0 ] || [[ $1 == "--help" ]] && print_usage && exit 0
while getopts ":d::s::qlv" opt; do
	case $opt in
		d)	optcount=$[ $optcount + 1 ]
			[[ $optcount > 1 ]] && echo "Illegal number of options" >&2 && print_usage >&2 && exit -2
			user=$OPTARG
			option=1
		;;
		s)	optcount=$[ $optcount + 1 ]
			[[ $optcount > 1 ]] && echo "Illegal number of options" >&2 && print_usage >&2 && exit -2
			user=$OPTARG
			option=2
		;;
		q)	quiet=1
		;;
		v)	verbose=1
		;;
		l)	[ $quiet -eq 1 ] || [ $optcount -gt 0 ] && echo "Illegal number of options" >&2 && print_usage >&2 && exit -2
			option=3
		;;
		\?)
			echo "Invalid option: -$OPTARG" >&2 && print_usage >&2
			exit -2
		;;
		:)
			echo "Option -$OPTARG requires an argument." >&2 && print_usage >&2
			exit -2
	esac
done
optcount=0
[ $verbose -eq 1 ] && optcount=$[ $optcount + 1 ]
[ $option -eq 3 ] && [ $[ $# - $optcount ] -gt 1 ] && echo "Invalid number of arguments">&2 && print_usage>&2 && exit -2
[ $quiet -eq 1 ] && optcount=$[ $optcount + 1 ]
[ $[ $# - $optcount ] -gt 2 ] && echo "Invalid number of arguments">&2 && print_usage>&2 && exit -2

# Setting user variable
if [ $option -eq 0 ]; then
	[ $optcount -eq 0 ] && user=$1
	[ $optcount -eq 1 ] && user=$2
	[ $optcount -eq 2 ] && user=$3
fi

# processing option -d i.e. deleting conffile
conffile=~/.cyberoam_$user.conf
if [ $option == 1 ]; then
	if [ -e $conffile ]; then
		rm $conffile && [ $verbose -eq 1 ] && echo "Configuration file deleted succesfully"
	else
		echo "Specified Configuration file not found."
	fi
	exit 0
fi

# Checking if another process is running
other=`ps -lC $name | grep -v PID | grep -v $$`
[ -n "$other" ] && other=`echo $other | awk '{print $4}'`
if [ $option -eq 3 ]; then # Logging out by sending SIGINT to other process
	if [ -z "$other" ]; then
		echo "No running process of $name found."
	else
		kill -INT $other
		pkill -P $other sleep
		[ $verbose -eq 1 ] && echo "`date +%H:%M:%S` : kill command sent."
	fi
	exit 0
elif [ -n "$other" ]; then #preventing duplicate processes from running
	echo "$name already running with pid $other."
	exit 0
fi

function gather_details {
	echo -n "Cyberoam server ip address: "
	read url
	echo -n "Password for $user: "
	read -s password
	echo ""
}

# processing option -s and the case with neither -s nor -d
if [ $option -eq 2 ]; then
	[ -e $conffile ] && echo "">$conffile
	gather_details
	echo "url='$url'">>$conffile
	echo "password=$password">>$conffile
elif [ -e $conffile ]; then
	. $conffile
else
	gather_details
fi

# Implement non-verbose cutoff from terminal i.e. takes itself to background
if [ $verbose -eq 0 ]; then
	comman="$name -v"
	[ $quiet -eq 1 ] && comman="$comman -q"
	[ ! -p ~/.cyberoam ] && mkfifo ~/.cyberoam
	( setsid $comman $user > /dev/null 2>&1 < ~/.cyberoam )&
	[ ! -e conffile ] && echo $url > ~/.cyberoam && echo $password > ~/.cyberoam
	exit 0
fi

function login {
	login_success=0
	trap - SIGINT
	echo "`date +%H:%M:%S` : Attempting login"
	local response=`curl -s -k -d mode=191 -d username=$user -d password=$password https://$url:8090/login.xml`
	if [[ $response =~ "successfully logged in" ]]; then
		echo "`date +%H:%M:%S` : Logged in successfully"
		[ $quiet -eq 0 ] && notify-send "Logged in successfully" "user: $user"
		login_success=1
		login_count=$LOGIN_COUNT_MAX
	elif [[ $response =~ "Maximum Login Limit" ]]; then
		echo "`date +%H:%M:%S` : Maximum Login Limit Reached"
		[ $quiet -eq 0 ] && notify-send "Maximum Login Limit Reached" "user: $user"
		exit -1
	else
		echo "`date +%H:%M:%S` : Login failed"
		login_count=$[ $login_count - 1 ]
		if [ $login_count -eq 0 ]; then
			[ $quiet -eq 0 ] && notify-send "Login Failed" "user: $user"
			exit 0
		fi
	fi
}

function ack {
	ack_success=0
	echo "`date +%H:%M:%S` : Sending keep-alive request"
	local response=`curl -s -k -G -d mode=192 -d username=$user https://$url:8090/live`
	[[ $response =~ "<ack><![CDATA[ack]]></ack>" ]] && ack_success=1
}

function logoutt {
	echo "`date +%H:%M:%S` : Attempting logout"
	local response=`curl -s -k -d mode=193 -d username=$user https://$url:8090/logout.xml`
	if [[ $response =~ "You have successfully logged off" ]]; then
		echo "`date +%H:%M:%S` : Logged out successfully"
		[ $quiet -eq 0 ] && notify-send "Logged out successfully" "user: $user"
	else
		echo "`date +%H:%M:%S` : Logout failed"
		[ $quiet -eq 0 ] && notify-send "Logout Failed" "user: $user"
	fi
	trap - SIGINT
	kill -INT $$
	exit 0
}

# attempt=0 means it will now attempt to login, 1 means ack
attempt=0
while [ 1 ]
do
	case $attempt in
		0)	login
			[[ $login_success == 1 ]] && attempt=1 && trap logoutt SIGINT
		;;
		1)	sleep 180
			ack
			if [[ $ack_success == 0 ]]; then
				echo "`date +%H:%M:%S` : Acknowledgement failed. Starting Acknowledgement tolerance countdown."
				[ $quiet -eq 0 ] && notify-send "Cyberoam Session Failed" "Trying again..."
				attempt=0
				ack_tolerate=$ACK_TOLERATE_MAX
				while [ $ack_tolerate -gt 0 ]; do
					ack_tolerate=$[ $ack_tolerate - 1 ]
					sleep $ACK_TOLERATE_SLEEP
					ack
					[ $ack_success -eq 1 ] && ack_tolerate=0
				done
				[ $ack_success -eq 0 ] && echo "`date +%H:%M:%S` : Acknowledgement Tolerance failed."
			fi
		;;
	esac
done
